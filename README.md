# vm5277 Embedded Java like toolkit
**Java-like embedded toolkit for Atmel, Microchip, STM8, and other MCUs**

Универсальная платформа для embedded-разработки( Java-подобный язык j8b + RTOS + кросс-платформенные драйверы для 8-битных МК)

## Лицензия
Проект распространяется под **Apache License 2.0**.
Ранние версии (до 2025-06-19) использовали GPL-3.0-or-later.

[Основной сайт vm5277](https://vm5277.ru "Официальный сайт vm5277")

# ЧЕРНОВИК: Описание работы компилятора (пример с кодогенератором для AVR)

## Основные принципы работы компилятора

### Распределение памяти под локальные переменные
Локальные переменные распределяются из следующих ресурсов:
1. **Регистры**:
   - `r20-r27`: полностью выделены под переменные и больше нигде не используются.
   - `r19-r17`: используются как переменными, так и аккумулятором. Аккумулятор временно задействуется в выражениях, сохраняя регистры, если они используются переменными. Также используется для возврата значения из метода.
   - `r16`: выделен под аккумулятор и используется как базовый регистр для алгоритмов.
   - `Y (r28, r29)`: хранит адрес начала блока памяти в стеке. Может использоваться для алгоритмов (с сохранением старого значения).
   - `Z (r30, r31)`: хранит адрес начала блока HEAP в динамической памяти. Также может использоваться для алгоритмов (с сохранением старого значения).
   - Реализован механизм переиспользования регистров.

2. **Фиксированный блок памяти в стеке(STACK FRAME)**:
   - Используется регистр `Y`.
   - Память под переменные в стеке выделяется для каждого кодового блока отдельно и освобождается по его завершении.

---

## Процедура создания экземпляра класса

### 1. Вызов конструктора
- Сохраняем старый адрес HEAP(регистр `Z`)
- Поочередно помещаем в стек все аргументы
- Вызываем конструктор
- Восстанавливаем адрес HEAP

**Пример ASM-кода:**
```asm
push_z
ldi zl,8
push zl
mcall j8bC11CByteMByte
pop_z
```

### 2. Конструктор(инициализация HEAP)
- Выделяем память для HEAP
- Заполняем заголовок класса
  - Размер HEAP (2 байта).
  - Количество ссылок на экземпляр класса (1 байт, изначально = 0, не освобождаем HEAP = 0ff).
  - Aдрес ранее созданной FLASH-таблицы с ид типов класса и интерфейсов, которые он реализует
    - Количество типов реализуемых интерфейсов, включая сам класс (1 байт).
    - Идентификатор типа класса (1 байт)
    - Идентификаторы интерфейсов (n байт).
  - Остальная память отведена под поля класса.
- Вызываем очистку нулями блока локальных переменных в HEAP
- Конструктор разделен на две части: 1 - инициализация HEAP, 2 - функционал верхнего уровня

**Пример ASM-кода:**
```asm
	ldi r16,6
	ldi r17,0
	mcall os_dram_alloc
	std z+0,r16
	std z+1,r17
	std z+2,c0x00
	ldi r16,low(j8bI10CByte*2)
	std z+3,r16
	ldi r16,high(j8bI10CByte*2)
	std z+4,r16
	mcall j8bproc_clear_heap_nr
```
### 3. Конструктор(реализация кода верхнего уровня)
- Z содержит адрес HEAP
- При необходимости создается STACK FRAME(для каждого кодового блока)
- На выходе STACK FRAME освобождается и восстанавливается Y
- Z восстанавливает вызывающий
- результат(адрес HEAP = this) возвращаем в аккумуляторе, аналогично возвращаем в аккумуляторе результат методов


### Передача THIS
- Если выражение-инициализатор (`NEW`) используется в присваивании, значение аккумулятора записывается в переменную/поле.
- Счетчик ссылок инкрементируется (в будущем будет проверка, чтобы увеличивать счетчик только для переменных с ссылками вне класса, а также решение проблемы циклических ссылок).

## Планы на будущее

### Исключения
- Представляют собой число размером 1 байт.
- Часть кодов будет зарезервирована для RTOS (например, `OSR_ALLOC_FAIL`).
- Для трассировки будет использоваться круговой буфер (экономия памяти).
- Логика пока не продумана.

### Сборщик мусора
- Не используется. Вместо него — механизм подсчета ссылок.
- Ресурс освобождается при нулевом счетчике ссылок.
- Планируется решение проблемы циклических ссылок.

### Рекурсия
- Все аргументы помещаются в стек, рекурсия возможна.
- На этапе семантического анализа будет проверяться размер стека.

### Многозадачность
- Переменные будут использовать регистры и HEAP (минимальное использование стека).
- Будут применяться блокировки диспетчера задач для атомарности.
- Задачи будут реализовываться как методы класса, поддерживающие интерфейс `Thread`.
- Регистры `r16-r31` подлежат сохранению.
- Переключение задач в вытесняющем режиме будет выполнять RTOS.

---

## Урезанная модель ООП
- Наследование не поддерживается (слишком ресурсоемко для 8-битных МК).
- Реализованы интерфейсы.

### Оператор `instanceof`
- Синтаксис изменен: вместо `if(obj instanceof Number)` используется `if(obj is Number as num)`, где `num` — новая локальная переменная типа `Number`.
- Проверка выполняется на уровне AST или в runtime (если невозможно на этапе компиляции). В HEAP класса включаются идентификаторы всех реализуемых интерфейсов.

---

## TODO
- Описать менеджер динамической памяти.
- Описать механизм переиспользования регистров.

---


**j8b сурс**
```Java
import rtos.System;
import rtos.RTOSParam;
import lang.Number;

class Main {
	public class Byte implements Number {
		private	byte	value;

		public Byte(byte value) {
			this.value = value;
		}

		public byte toByte() {
			byte t=0;
			return value+t;
		}
	}

    public static void main() {
		System.setParam(RTOSParam.STDOUT_PORT, 0x12);

		Byte b1 = new Byte(0x08);
		System.out(b1.toByte());
    }
}
```
**Результат**
```asm
.equ stdout_port = 18

.set OS_FT_DRAM = 1
.set OS_FT_STDOUT = 1

.include "devices/atmega328p.def"
.include "core/core.asm"
.include "dmem/dram.asm"
.include "j8b/inc_refcount.asm"
.include "j8b/dec_refcount.asm"
.include "j8b/clear_heap.asm"
.include "stdio/out_num8.asm"

Main:
	jmp j8bCMainMmain
j8bI0CMain: .db 1,13
j8bI10CByte: .db 2,14,12,0
j8bC11CByteMByte:
	ldi r16,6
	ldi r17,0
	mcall os_dram_alloc
	std z+0,r16
	std z+1,r17
	std z+2,c0x00
	ldi r16,low(j8bI10CByte*2)
	std z+3,r16
	ldi r16,high(j8bI10CByte*2)
	std z+4,r16
	mcall j8bproc_clear_heap_nr
j8bCI12CByteMByte:
	ldd r16,y+0
	std z+5,r16
j8bE13CByteMByteB19:
	ret
j8bC14CByteMtoByte:
	ldi r20,0
	mov r16,r20
	push yl
	ldd yl,z+5
	add r16,yl
	pop yl
	jmp j8bE15CByteMtoByteB21
j8bE15CByteMtoByteB21:
	ret
j8bCmainMmain:
	push_z
	ldi zl,8
	push zl
	mcall j8bC11CByteMByte
	pop_z
	mov r20,r16
	mov r21,r17
	push_z
	mov r30,r20
	mov r31,r21
	mcall j8bC14CByteMtoByte
	pop_z
	mcall os_out_num8
j8bE16CMainMmainB24:
	ret
```

