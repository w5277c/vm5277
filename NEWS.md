# Новости и история разработки


## [2025-12-09] - Реализация системы исключений, оптимизация и рефакторинг кодогенератора для AVR

### ✅ Статус
Реализована полноценная система исключений (exception) с поддержкой иерархии, автоматический импорт классов из конфигурации. Улучшена обработка try-catch. Внесены значительные изменения в **низкоуровневый кодогенератор AVR**: добавлены проверки исключений в арифметических операциях, оптимизация переходов, поддержка различных инструкций вызова и улучшенная работа с регистрами. Также реализована **система трассировки исключений в RTOS** и **программный бутлоадер** для AVR.

### Ключевые изменения

#### 1. Система исключений (Exception) — высокоуровневые изменения
- **Новый тип исключений:** Добавлено ключевое слово `exception` для объявления типов исключений с поддержкой иерархии через `extends`.
- **Блоки catch:** Реализован механизм catch с поддержкой нескольких типов исключений и переменной для хранения кода исключения.
- **Метод throw:** Добавлен метод `throw()` для классов исключений, заменяющий оператор `throw`.
- **Иерархия исключений:** Реализована проверка совместимости исключений через наследование.

#### 2. Автоматический импорт классов
- **Конфигурационный файл:** Добавлена поддержка автоматического импорта классов из `runtime/autoimport.cfg`.
- **Динамическая загрузка:** Классы из конфигурации автоматически загружаются и парсятся перед компиляцией основного исходнного кода.

#### 3. Переработанный черновой механизм try-catch
- **Новый синтаксис:** Изменен формат блока catch: `catch(Exception1, Exception2 e) { ... }`.
- **Удален оператор throw:** Ключевое слово `throw` удалено из языка, заменено методом `Exception.throw()`.
- **Обработка вложенных исключений:** Улучшена поддержка вложенных try-catch блоков и проверка обработки исключений.

#### 4. Рефакторинг системы типов
- **Унификация VarType:** Класс `VarType` перемещен в общий пакет `ru.vm5277.common`.
- **Новые типы данных:** Добавлены типы `EXCEPTION`.
- **Система идентификаторов:** Реализована система ID для исключений и проверка совместимости типов.

#### 5. Улучшения кодогенерации — высокоуровневые
- **Обработка исключений:** Добавлена генерация кода для проверки и передачи исключений через стек вызовов.
- **Метки переходов:** Улучшена система меток для обработки исключений (CATCH_SKIP, COMPARE_END).
- **Информация для отладки:** Добавлен вывод файла `.dbg` с информацией о точках выбрасывания исключений.

#### 6. Низкоуровневый кодогенератор AVR — ключевые изменения
- **Класс `ExcsChecker`:** Новый класс для встраивания проверок исключений в сгенерированный ассемблерный код:
    - `stackOverflow` — проверка переполнения стека при аллокации.
    - `mathOverflow` — проверка арифметического переполнения.
    - `divByZero` — проверка деления на ноль.
    - `outOfMemory` — проверка нехватки памяти.
    - `invalidIndex` — проверка выхода за границы массива.
    - `arrMathOverflow`, `arrOutOfMemory` — проверки при создании массивов.

- **Класс `Fixer`:** Новый класс для исправления относительных переходов (branch range fixer):
    - Заменяет `brXX` на `jmp`, если расстояние превышает 64 слова.
    - Использует инвертирование условий для оптимизации.

- **Класс `Generator` — значительные изменения:**
    - **Инструкции вызова:** Добавлены настраиваемые `CALL_INSTR` и `JUMP_INSTR` (могут быть `rcall`/`call`, `rjmp`/`jmp` в зависимости от MCU).
    - **Проверки исключений в арифметике:** Вызовы `ExcsChecker` добавлены в операции:
        - `constAction` — для `PLUS`, `MINUS`, `MULT`, `DIV`, `MOD`.
        - `cellsAction` — аналогично.
        - `eUnary` — для инкремента/декремента.
    - **Работа с регистрами:** Улучшены методы `movw` вместо парных `mov`, использование `ldi` с непосредственными значениями.
    - **Новые методы:**
        - `terminate` — завершение программы с обработкой исключений и режимами остановки (HALT, BLINK, RESET).
        - `eThrow` — генерация кода для выбрасывания исключения.
        - `throwCheck` — проверка наличия необработанного исключения.
    - **Работа с памятью:** Улучшены `eNewInstance`, `eNewArray`, `eNewArrView` с интеграцией проверок `outOfMemory`.

- **Класс `Optimizer` — улучшения:**
    - **Оптимизация переходов:** Замена `jmp` → `rjmp` и `call` → `rcall` при допустимой дальности.
    - **Оптимизация парных инструкций:** Объединение `mov` → `movw`, `subi`+`sbci` → `adiw`.
    - **Удаление избыточных загрузок:** Устранение повторных `ldi` в один регистр.

#### 7. Реализация системы исключений в RTOS (низкоуровневые изменения)
- **Новые модули трассировки исключений:**
    - `j8b/etrace_add.asm` — добавление точки прохода в буфер исключений
    - `j8b/etrace_clear.asm` — очистка буфера исключений
    - `j8b/etrace_out.asm` — вывод трассировки исключений через stdout
- **Буфер исключений в памяти:** Добавлена структура `_OS_ETRACE_BUFFER` с двумя форматами хранения:
    - 7-битные идентификаторы точек (экономия памяти)
    - 15-битные идентификаторы (для сложных систем)
- **Признак переполнения:** Старший бит указывает на переполнение буфера трассировки
- **Новый флаг RTOS:** `OS_FT_ETRACE` для включения системы трассировки исключений

#### 8. Программный бутлоадер для AVR
- **Новый файл:** `rtos/avr/boot/bootloader.asm`
- **Функциональность:**
    - Полноценный UART-загрузчик (half-duplex, 8N0)
    - Поддержка команды записи страниц Flash (`'w'`)
    - Проверка контрольной суммы (XOR)
    - Защита от перезаписи самого бутлоадера
    - Команды: `'v'` — показать версию, `'g'` — запустить программу
- **Автозапуск:** При старте проверяется наличие прошивки и состояние пина RST
- **Конфигурируемость:** Порт бутлоадера задается через `PORT_BLDR`, `DDR_BLDR`, `PIN_BLDR`
- **Новый флаг:** `OS_FT_BOOTLOADER_ONLY` для сборки только бутлоадера

#### 9. Оптимизации ядра RTOS
- **Условная компиляция:** Критические функции теперь включаются только при необходимости:
```asm
    .IF OS_FT_IR_TABLE == 0x01 || OS_FT_DIAG == 0x01
    .include "mem/ram_fill.asm"
    .ENDIF
```

- **Универсальная задержка:** В `wait_ms.asm` добавлена работа без таймера через программные циклы

#### 10. Улучшения арифметических операций
- **Безопасное умножение:** В `mul8.asm` исправлено сохранение регистров `r0`, `r1` и флагов

#### 11. Новые системные функции
- **MCU управление:** Добавлены модули:
    - `sys/mcu_blink_forever.asm` — бесконечное мигание светодиодом
    - `sys/mcu_blink_n_reset.asm` — мигание + сброс
    - `sys/mcu_halt.asm` — переход в энергосберегающий режим
    - `sys/mcu_reset.asm` — программный сброс через watchdog
- **Утилиты вывода:** Добавлен `stdio/out_hex8.asm` для вывода чисел в шестнадцатеричном формате

#### 12. Конфигурационные улучшения
- **Новые флаги RTOS:**
    - `OS_FT_BOOTLOADER_ONLY` — сборка только бутлоадера
    - `OS_FT_HEARTBEAT` — индикация работы RTOS
    - `OS_FT_ETRACE` — включение трассировки исключений
- **Параметры памяти:**
    - `OS_ETRACE_BUFFER_SIZE` — размер буфера исключений (по умолчанию 16 байт)
- **Поддержка чипов:** В `atmega328p.def` добавлены константы для бутлоадера на пине RST (PC6)

#### 13. Архитектурные улучшения
- **Разделение ответственности:** Кодогенератор разделен на `Generator`, `Optimizer`, `Fixer`, `ExcsChecker`.
- **Поддержка MCU:** Добавлена возможность выбирать инструкции в зависимости от наличия `call`/`jmp`.

#### 14. Инфраструктурные изменения
- **Параметр max-errors:** Добавлена опция `--max-errors` для ограничения количества выводимых ошибок.
- **Улучшенные сообщения об ошибках:** Более информативные сообщения при отсутствии файлов тулкита.
- **Поддержка параметров RTOS:** `SystemParam` переименован в `RTOSParam`, добавлены новые параметры (`ACTLED_PORT`, `HALT_OK_MODE` и др.).

#### 15. Удаление устаревшего функционала
- **Удален `ArrayDeclarationNode`:** Объявление массивов интегрировано в общий механизм объявления переменных.
- **Удален `ThrowNode`:** Заменен методом исключений `throw()`.
- **Удален `sys/mcu_stop.asm`:** В пользу нового `mcu_halt.asm`.

### Технические детали
- **Новые RTOS функции:** Добавлены функции для работы с исключениями в рантайме (`j8bproc_etrace_add`, `j8bproc_etrace_addfirst`, `j8bproc_etrace_clear`, `j8bproc_etrace_out`).
- **Улучшенная диагностика:** Добавлены проверки на необработанные исключения в методах.
- **Поддержка unchecked исключений:** Реализована поддержка непроверяемых исключений.
- **Оптимизация импортов:** Улучшена работа с импортированными классами и интерфейсами.

### Архитектурные изменения
- **Разделение областей видимости:** Добавлены `ExceptionScope` и `ImportableScope` для лучшей организации кода.
- **Унифицированные интерфейсы:** Классы, интерфейсы и исключения теперь используют общую иерархию `ObjectTypeNode`.
- **Улучшенная модульность:** Код разделен на более четкие модули с определенными ответственностями.

### Итог
Обновление представляет собой **масштабный рефакторинг и доработку** как высокоуровневой системы (исключения, типы, импорты), так и низкоуровневого кодогенератора AVR и RTOS. Теперь система:

1.  **Поддерживает полноценные исключения** с иерархией и проверками на всех уровнях
2.  **Автоматически импортирует классы** из конфигурации
3.  **Генерирует более эффективный и безопасный код** с проверками на переполнение, деление на ноль и выход за границы
4.  **Реализует трассировку исключений в RTOS** с буфером и функциями отладки
5.  **Включает программный бутлоадер** для удаленного обновления прошивки
6.  **Оптимизирует переходы и инструкции** для экономии памяти и повышения производительности
7.  **Обеспечивает условную компиляцию** критических функций для уменьшения размера прошивки


**Смотрите файлы-примеры в директории examples/j8b и результат кодогенерации в examples/j8b/target/**  

### Следующие шаги
- Множественные мелкие доработки и багфиксинг
- Старт отладки кода на реальном железе - Atmega328


## [2025-11-21] - Реализация switch-case и доработка семантики

### ✅ Статус
Реализован switch-case, улучшена работа с массивами, добавлена поддержка операторов break/continue с метками, улучшена кодогенерация для циклов и оператора return.

### Ключевые изменения
#### 1. Улучшения работы с массивами
- **Новая процедура выделения памяти:** Добавлена специализированная процедура j8bproc_new_array для оптимизации создания массивов и иницализации ячеек

#### 2. Поддержка меток для break/continue
- **Именованные переходы:** Реализована полная поддержка break label и continue label для управления вложенными циклами
- **Проверка областей видимости:** Добавлена валидация меток в пределах текущего метода

#### 3. Реализация оператора switch
- **Поддержка диапазонов:** Реализована обработка case-значений с диапазонами (case 1..10:) и множественными значениями (case 15,20..25,30:)
- **Константная оптимизация**: Добавлена оптимизация switch с константными выражениями на этапе компиляции
- **Проверка уникальности:** Контроль дублирующихся case-значений с учетом уровня строгости компиляции

#### 4. Доработка циклов
- **Оптимизация do-while:** Добавлена полная поддержка оператора do-while с константным анализом условий
- **Метки циклов:** Введены специализированные метки LOOP_START, LOOP_NEXT, LOOP_END для улучшения кодогенерации
- **Статический анализ:** Улучшено определение всегда истинных/ложных условий циклов

#### 5. Улучшения оператора return
- **Корректный выход из методов:** Исправлена кодогенерация для оператора return с учетом вложенных блоков
- **Оптимизация выражений:** Добавлена оптимизация возвращаемых выражений через optimizeWithScope

#### 6. Общие улучшения кодогенерации
- **Система меток:** Переработана система управления метками в блоках кода
- **Обработка констант:** Расширена поддержка константных выражений и enum-типов
- **AST Inlining:** Добавлена обработка ненулевых смещений при работе с кучей (HEAP_ALT)

### Технические детали
- **Новые RTOS библиотеки:** Добавлена библиотека NEW_ARRAY для оптимизированного создания массивов
- **Улучшенная диагностика:** Добавлены проверки на недостижимый код после прерывающих инструкций
- **Поддержка enum:** Расширена оптимизация выражений с enum-типами

### Пример использования
```Java
outer:
for(byte i=0; i<10; i++) {
    inner:
    for(byte j=0; j<10; j++) {
        if(i==5 && j==5) break outer;
        if(j<3) continue inner;
    }
}

// break не поддерживается и не требуется - выполняется только соответствующий case
switch(value) {
    case 0: System.out(0);
    case 1..10: {
		System.out(1);
    }
    case 15,20..25,30: System.out(2);
    default:
        System.out(3);
}

do {
    System.out('!');
    i++;
} while(i<20);
```

### Следующие шаги
- Реализация системы исключений (try, catch, throw)
- Расширение runtime проверок безопасности (после try-catch)


## [2025-11-15] - Множественные улучшения

### 1. Рефакторинг иерархии классов и областей видимости
- Введен базовый класс ObjectTypeNode - общая база для ClassNode и InterfaceNode
- Создан базовый класс CIScope - для общих функций Class и Interface Scope
- Упрощена иерархия Scope: ClassScope, InterfaceScope, EnumScope наследуются от CIScope

### 2. Реорганизация системы выражений (Expressions)
- Разделение BinaryExpression на специализированные классы в пакете bin:
  - ArithmeticExpression - арифметические операции
  - AssignExpression - операции присваивания
  - ComparisonExpression - операции сравнения

- Создан ExpressionsContainer - контейнер для управления списком выражений
- Создан QualifiedPathExpression - для квалифицированных путей (obj.field.subfield.method())
- Удален UnresolvedReferenceExpression - функциональность перенесена

### 3. Улучшение системы типов
- Удалена поддержка enum-типов через isEnum()
- Добавлена проверка совместимости классовых типов и интерфейсов
- Улучшена обработка приведений типов и проверка совместимости
- Упрощено определение типов в LiteralExpression (вычисляется в конструкторе)

### 4. Расширение ООП-функциональности
- Улучшена обработка статических полей и методов

### 5. Улучшения работы с массивами
- Полная реструктуризация ArrayExpression:
- Упрощение ArrayInitExpression

### 6. Оптимизации компилятора
- Добавлена опция frontend-оптимизации (Optimization.FRONT)
- Улучшена свертка констант и оптимизация арифметических цепочек
- Оптимизация операций - замена умножения/деления на степени двойки сдвигами

### 7. Улучшения кодогенерации
- Переработана система ветвлений с использованием CGBranch
- Добавлена оптимизация константных выражений
- Улучшена работа с кучей (heap) и обработка массивов
- Добавлена генерация для тернарных операторов

### 8. Диагностика и отладка
- Добавлена система отладочного вывода AST (DEBUG_AST)
- Улучшены сообщения об ошибках и предупреждениях
- Добавлена трассировка фаз семантического анализа
- Улучшено отслеживание позиций в исходном коде (SourcePosition)

### 9. Улучшения валидации
- Добавлена проверка недостижимого кода
- Улучшена проверка самоприсваивания в FieldNode
- Добавлена проверка статического контекста и final переменных
- Улучшена проверка границ и совместимости типов

### 10. Улучшения парсера и лексера
- Добавлена поддержка табуляции с настраиваемым размером (tabSize)
- Улучшена обработка квалифицированных выражений
- Добавлена система отложенного разрешения объявлений
- Улучшена обработка forward references

### 11. Улучшения в конкретных выражениях
- MethodCallExpression - переработана структура, добавлена поддержка нативных методов
- PropertyExpression - расширена поддержка свойств enum, массивов и классов
- VarFieldExpression - добавлен режим инлайнинга, улучшена проверка доступа
- InstanceOfExpression, UnaryExpression - улучшена оптимизация через optimizeWithScope

### 12. Улучшения в RTOS
- Добавлен пул статических данных OS_STAT_POOL
- Добавлены функции завершения методов J8BPROC_MFIN и J8BPROC_MFIN_SF
- Добавлены процедуры умножения/деления на степени двойки


**Смотрите файлы-примеры в директории examples/j8b и результат кодогенерации в examples/j8b/target/**  

### Следующие шаги
- Реализация краткой базовой документации для желающих начать эксперименты над проектом (альфа-версия)
- Реализация конструкции switch-case



## [2025-11-10] - Текущий статус проекта

### ✅ Статус
Ведутся работы по рефакторингу кода компилятора. Устраняются накопленные ошибки и улучшается архитектура. Движемся к beta версии.

### Что делается
- Исправление багов на всех уровнях проекта
- Ввод QualifiedExpression
- Рефакторинг BinaryExpression -> ArithmeticExpression, AssignExpression, ComparisonExpression
- Общий рефакторинг семантики и frontend кодогенерации
- Улушения в оптимизации, в том числе реализация AST Inlining
- Расширение кода примеров
- Финализация механизма вызова методов
- И много, много мелких доработок...

### Ожидания
Планируется выпуск обновления в ближайшее время после завершения текущего цикла работ.


## [2025-10-11] - Реализация поддержки enum типов

### ✅ Статус
Реализована полная поддержка перечисляемых типов (enum). Добавлены новые синтаксические конструкции, свойства enum и интеграция с существующей системой типов.

### Цель
Реализовать тип данных enum для создания именованных константных значений с проверкой типов на этапе компиляции и c нулевой нагрузкой на runtime. Обеспечить поддержку свойств enum и интеграцию с существующими языковыми конструкциями.

### Исходный код (Java-подобный)
```Java
class Main {

	public enum EDirection {
		LEFT,
		RIGHT,
		DOWN,
		UP;
	}

	public enum EStatus {
		OK,
		ERROR
	}

    public static void main() {
		System.setParam(RTOSParam.STDOUT_PORT, 0x12);

		System.out(EStatus.ERROR.index());
		System.out(EStatus.size());

		EDirection dir = EDirection.item(1);
		if(EDirection.UP==dir) {
			System.out(0x01);
		}
		else {
			System.out(0x00);
		}

		printDirection(EDirection.UP);

		EStatus st = EStatus.OK;
		System.out(st.index());

		EStatus s = EStatus.item(EStatus.ERROR.index());
		System.out(s.index());

		System.out(EStatus.item(1).index());

//Приводит к ошибкам компиляции
/*		System.out(EStatus);
		System.out(EStatus.UP);
		System.out(EStatus.OK.length);
		System.out(EStatus.length);
		System.out(EStatus.OK.size());
		System.out(EStatus.ERROR.item(1));
		System.out(EStatus.index());
		EStatus es1 = EStatus.item(5);
		EStatus es2 = EStatus.item(-1);
		EStatus es3 = EStatus.item(0, 1);
		System.out(es1.size(1));
*/
    }

    public void printDirection(EDirection dir) {
		System.out(dir.index());
	}
}
```

### Результат на AVR ассемблере

```asm
; vm5277.avr_codegen v0.1 at Sat Oct 11 01:40:29 VLAT 2025
.equ stdout_port = 18

.set OS_FT_STDOUT = 1
.set OS_FT_DRAM = 1

.include "devices/atmega328p.def"
.include "core/core.asm"
.include "dmem/dram.asm"
.include "stdio/out_num8.asm"

Main:
	rjmp j8bCMainMmain
_j8b_meta20:
	.db 12,0

j8bCMainMmain:
	ldi r16,1
	rcall os_out_num8
	ldi r16,2
	rcall os_out_num8
	ldi r16,1
	mov r20,r16
	ldi r16,3
	cp r16,r20
	brne _j8b_eoc22
	ldi r16,1
	rcall os_out_num8
_j8b_eob23:
	rjmp _j8b_eob24
_j8b_eoc22:
	ldi r16,0
	rcall os_out_num8
_j8b_eob24:
	ldi r19,3
	push r19
	rcall j8bC25CMainMprintDirection
	pop j8b_atom
	ldi r21,0
	mov r16,r21
	rcall os_out_num8
	ldi r16,1
	mov r22,r16
	mov r16,r22
	rcall os_out_num8
	ldi r16,1
	rcall os_out_num8
_j8b_eob21:
	ret

j8bC25CMainMprintDirection:
	push yl
	push yh
	lds yl,SPL
	lds yh,SPH
	ldd r16,y+5
	rcall os_out_num8
_j8b_eob26:
	ret
```

### Ключевые изменения
#### 1. Новая система типов для enum
- **VarType.java**: Добавлены поддержка enum типов, методы для создания и получения enum типов
- **Типизация**: Enum представлен как byte с автоматической нумерацией значений
- **Свойства**: Поддержка методов .index(), item(x) и .size()

#### 2. Новые AST узлы
- **EnumNode.java**: Узел для объявления enum с модификаторами и значениями
- **EnumExpression.java**: Выражение для доступа к значениям enum
- **PropertyExpression.java**: Универсальное выражение для свойств (заменило ArrayPropertyExpression)

#### 3. Синтаксический анализ
- **AstNode.java**: Добавлена поддержка парсинга enum объявлений и выражений
- **BlockNode.java, ClassBlockNode.java, InterfaceBodyNode.java**: Интеграция enum в различные контексты объявлений

#### 4. Семантический анализ
- **UnresolvedReferenceExpression.java**: Расширена логика разрешения ссылок для поддержки enum
- **Множественные улучшения**: Добавлена обработка enum в различных выражениях и операторах

#### 5. Кодогенерация
- **Представление**: Значения enum компилируются как байтовые константы


### Особенности реализации
- **Безопасность типов**: Компилятор проверяет корректность использования enum значений
- **Эффективность**: Enum значения представлены как byte в runtime
- **Свойства**: Встроенная поддержка .index() для получения порядкового номера, .item(x) для получения элемента по порядковому номеру, и .size() для получения количества элементов
- **Интеграция**: Полная поддержка в присваиваниях, операциях сравнения

### Ограничения
- Enum не поддерживают пользовательские методы или конструкторы
- Значения enum должны быть уникальными идентификаторами в верхнем регистре
- Поддержка только в классах и глобальной области видимости

###Технические детали
- **Размер типа**: 1 байт (аналогично byte)
- **Методы**: Автоматическая генерация методов доступа к свойствам
- **Проверки**: Разрешены только операции присваивания и сравнения(EQ/NEQ)

### Следующие шаги
- **Очередное тестирование**: Внесены множественные изменения, необходимо проверить старые примеры
- **Операторы управления**: `continue`, `switch`
- **Метки**: Именованные переходы для вложенных циклов



## [2025-10-08] - Реализация оператора while

### ✅ Статус
Реализована(аналогичная оператору for) полная поддержка оператора while со всеми вариантами синтаксиса, включая поддержку break.

## [2025-10-08] - Реализация оператора for с поддержкой break и for-else

### ✅ Статус
Реализована полная поддержка оператора for со всеми вариантами синтаксиса, включая поддержку break и конструкции for-else по аналогии с Python.
Добавлена оптимизация циклов с вычислением константных условий на этапе компиляции.
Изменения были частично протестированы на уровне кодогенерации. Код демонстрирует корректную работу с регистрами и эффективную генерацию ассемблера.

### Цель
Реализовать оператор for с полной поддержкой различных синтаксических форм, включая бесконечные циклы, циклы с внешними переменными, и уникальную конструкцию for-else.
Обеспечить корректную работу break внутри циклов и интегрировать систему областей видимости для управления метками переходов.

### Исходный код (Java-подобный)
```Java
class Main {
    public static void main() {
		System.setParam(RTOSParam.STDOUT_PORT, 0x12);

		// For с break и else
		for(byte i=0; i<10; i++) {
			if(1==i) break;
			System.out(i);
		}
		else {
			System.out('!');  // Не выполнится из-за break
		}

		// Различные варианты for
		for(byte i=7; 4>8; i++) {	// Оптимизируется - удаляется
			System.out(i);
		}
		for(byte i=8; 4<8; i++) {	// Бесконечный цикл
			System.out(i);
		}
		for(byte i=0; ; i++); {		// Бесконечный без условия
			System.out(i);
		}
    }
}
```

### Результат на AVR ассемблере

```asm
; vm5277.avr_codegen v0.1 at Wed Oct 08 15:38:05 VLAT 2025
.equ stdout_port = 18

.set OS_FT_STDOUT = 1
.set OS_FT_DRAM = 1

.include "devices/atmega328p.def"
.include "core/core.asm"
.include "dmem/dram.asm"
.include "stdio/out_num8.asm"

Main:
	rjmp j8bCMainMmain
_j8b_meta20:
	.db 12,0

j8bCMainMmain:
	ldi r20,0
_j8b_loop43:
	cpi r20,10
	brcc _j8b_eoc24
	cpi r20,1
	breq _j8b_eol23
	mov r16,r20
	rcall os_out_num8
	add r20,C0x01
	rjmp _j8b_loop43
_j8b_eoc24:
	ldi r16,33
	rcall os_out_num8
_j8b_eol23:

	ldi r20,8
_j8b_loop45:
	mov r16,r20
	rcall os_out_num8
	add r20,C0x01
	rjmp _j8b_loop45

	ldi r20,0
_j8b_loop46:
	mov r16,r20
	rcall os_out_num8
	add r20,C0x01
	rjmp _j8b_loop46
	ret
```

**Смотрите также файл-пример for.j8b**

### Ключевые изменения
#### 1. Поддержка всех форм оператора for
- **Классический for**: for(byte i=0; i<10; i++)
- **Бесконечный for**: for(byte i=0; ; i++)
- **For с внешней переменной**: byte i=0; for(; i<10; i++)
- **For без инкремента**: for(byte i=0; i<10;)

#### 2. Конструкция for-else
- **Семантика Python**: else-блок выполняется только при нормальном завершении цикла (без break)

#### 3. Оптимизация циклов
- **Статический анализ**: Вычисление условий на этапе компиляции
- **Константные условия**: Циклы с всегда ложными условиями полностью удаляются

#### 4. Система областей видимости
- **CGLoopBlockScope**: Новая область видимости для управления метками циклов
- **Поддержка break**: Корректный выход из вложенных циклов
- **Регистровая аллокация**: Эффективное переиспользование регистров между циклами

### Следующие шаги
- **Операторы управления**: `continue`, `switch`
- **Метки**: Именованные переходы для вложенных циклов



## [2025-10-07] - Реализация поддержки массивов и оптимизация кода

### ✅ Статус
Реализована полная поддержка многомерных массивов, добавлены новые оптимизации и улучшена система кодогенерации.
Внесены значительные изменения в архитектуру компилятора для поддержки сложных структур данных.
**Изменения не были протестированы на реальном устройстве или в симуляторе**.
Код будет всесторонне проверен и отлажен в будущем. Пока ключевая цель - общая реализация кодогенератора.

### Цель
Реализовать полную поддержку многомерных массивов в языке J8B, включая создание, инициализацию, доступ к элементам и свойствам массивов.
Одновременно внедрить систему оптимизаций для улучшения производительности генерируемого кода и расширить возможности кодогенератора для работы со сложными структурами данных.

### Исходный код (Java-подобный)
```Java
class Main {
    public static void main() {
		System.setParam(RTOSParam.STDOUT_PORT, 0x12);

		byte b1 = 254;
		fixed[][] arr = new fixed[][]{{0.5,-1},{-2*2,(fixed)b1},{-4,100.99}};
		System.out(arr[0][0]);

		byte size=8;
		short[] arr2 = new short[size];
		arr2[1] = 3;

		short s=0x0101;
		s++;
		if(s<arr2[3]) {
			System.out(arr2[3]);
		}

		arr[0][0] = arr2[1];
		arr = null;
		arr2 = null;
	}
}
```

### Результат на AVR ассемблере

```asm
; vm5277.avr_codegen v0.1 at Tue Oct 07 02:00:17 VLAT 2025
.equ stdout_port = 18

.set OS_ARRAY_2D = 1
.set OS_FT_STDOUT = 1
.set OS_FT_DRAM = 1
.set OS_ARRAY_1D = 1

.include "devices/atmega328p.def"
.include "core/core.asm"
.include "dmem/dram.asm"
.include "j8b/arr_celladdr.asm"
.include "j8b/arr_refcount.asm"
.include "mem/rom_read16.asm"
.include "stdio/out_num16.asm"
.include "stdio/out_q7n8.asm"

j8bD25:
.dw 128,0,0,32256,0,25853

Main:
	rjmp j8bCMainMmain
_j8b_meta20:
	.db 12,0

j8bCMainMmain:
	ldi r16,19
	ldi r17,0
	push r30
	push r31
	rcall os_dram_alloc
	movw r26,r30
	pop r31
	pop r30
	movw r16,xl
	ldi r19,17
	st x+,r19
	st x+,C0x01
	ldi r19,9
	st x+,r19
	ldi r19,3
	st x+,r19
	st x+,c0x00
	ldi r19,2
	st x+,r19
	st x+,c0x00
	push r17
	push r16
	push zl
	push zh
	ldi zl,low(j8bD25*2)
	ldi zh,high(j8bD25*2)
	ldi r16,low(12)
	ldi r17,high(12)
	rcall os_rom_read16_nr
	pop zh
	pop zl
	pop r16
	pop r17
	movw r20,r16
	push c0x00
	push c0x00
	push c0x00
	push c0x00
	movw r26,r20
	rcall j8bproc_arr_celladdr
	ld r16,x+
	ld r17,x
	rcall os_out_q7n8
	ldi r16,21
	ldi r17,0
	push r30
	push r31
	rcall os_dram_alloc
	movw r26,r30
	pop r31
	pop r30
	movw r16,xl
	ldi r19,16
	st x+,r19
	st x+,C0x01
	ldi r19,9
	st x+,r19
	ldi r19,8
	st x+,r19
	st x+,c0x00
	movw r22,r16
	push c0x01
	push c0x00
	movw r26,r22
	rcall j8bproc_arr_celladdr
	ldi r16,3
	st x+,r16
	st x,c0x00
	ldi r24,1
	ldi r25,1
	add r24,C0x01
	adc r25,C0x00
	movw r16,r24
	ldi r19,3
	push r19
	push c0x00
	movw r26,r22
	rcall j8bproc_arr_celladdr
	ld r19,-x
	cp r17,r19
	breq pc+0x02
	brcc _j8b_eoc22
	ld r19,-x
	cp r16,r19
	brcc _j8b_eoc22
	ldi r19,3
	push r19
	push c0x00
	movw r26,r22
	rcall j8bproc_arr_celladdr
	ld r16,x+
	ld r17,x
	rcall os_out_num16
_j8b_eoc22:
	push c0x01
	push c0x00
	movw r26,r22
	rcall j8bproc_arr_celladdr
	ld r16,x+
	ld r17,x
	push c0x00
	push c0x00
	push c0x00
	push c0x00
	movw r26,r20
	rcall j8bproc_arr_celladdr
	mov r17,r16
	clr r16
	st x+,r16
	st x,r17
	movw r26,r20
	rcall j8bproc_arr_refcount_dec
	ldi r20,0
	ldi r21,0
	movw r26,r22
	rcall j8bproc_arr_refcount_dec
	ldi r22,0
	ldi r23,0
	ret
```

**Смотрите также файлы-примеры arrays.j8b, arrays2.j8b, arrays3.j8b**

### Ключевые изменения

#### 1. Поддержка многомерных массивов
- **Новые классы выражений**:
  - `NewArrayExpression` - создание массивов с указанием размерностей
  - `ArrayExpression` - доступ к элементам массива
  - `ArrayInitExpression` - инициализация массивов
  - `ArrayPropertyExpression` - доступ к свойствам массивов (length)

- **Типизация массивов**: Добавлена поддержка массивов любой вложенности (до 3 уровней)
- **Инициализация**: Поддержка инициализации `{1, value, 3, arr[1]}`
- **Доступ к элементам**: Полная поддержка многомерного индексирования `arr[i][j][k]`

#### 2. Система оптимизаций
- **Уровни оптимизации**: Добавлены флаги `-o none|size|speed`
- **Свёртка констант**: Улучшена оптимизация арифметических выражений
- **Оптимизация логических операций**: Сокращённые вычисления для `&&` и `||`
- **Выявление константных переменных**: Автоматическое определение `final` переменных

#### 3. Улучшения кодогенерации
- **Улучшена система областей видимости**: Переработана архитектура CGScope
- **Оптимизация работы с памятью**: Улучшено распределение регистров и стековых фреймов

#### 4. Существенный багфиксинг
- **Особое внимание к классам выражений**: Исправлено множество ошибок и расширен функционал


### Следующие шаги
- **Операторы управления**: `for`, `break`, `continue`, `switch`
- **Метки**: Именованные переходы для вложенных циклов



## [2025-09-16] - Полная реализация boolean типа и логических операций

### ✅ Статус
Реализация завершена на уровне кодогенерации, но **не была протестирована на реальном устройстве или в симуляторе**.
Код будет всесторонне проверен и отлажен в будущем. Пока ключевая цель - общая реализация кодогенератора.
Boolean тип теперь поддерживает все операции, включая логические выражения в условиях, присваиваниях и возвращаемых значениях.

### Цель
Реализовать полную поддержку типа `bool` со всеми логическими операциями (`&&`, `||`, `!`), сравнениями (`==`, `!=`) и интеграцией с условными операторами.

### Исходный код (Java-подобный)

```java
import rtos.System;
import rtos.RTOSParam;

class Main {

	public bool test(bool _b1, bool _b2) {
		return _b1 && _b2;
	}

    public static void main() {
		System.setParam(RTOSParam.STDOUT_PORT, 0x12);

		bool b10 = true;
		bool b1 = true;
		bool b2 = false;

		System.out(true);
		System.out(false);
		System.out(!true);
		System.out(!false);
		System.out(b1);
		System.out(b2);
		System.out(!b1);
		System.out(!b2);

		bool b3 = !b1;
		System.out(b3);

		if(b1==b2) {
			System.out('0');
		}

		if(b1) {
			System.out('1');
		}
		if(b2) {
			System.out('2');
		}
		if(!b2) {
			System.out('3');
		}

		if(b1 || b2) {
			System.out('4'); //52
		}
		if(b1 && b2) {
			System.out('5'); //53
		}

		System.out(test(b1, b2));

		bool b4 = b1 || b2 || b10;
		System.out(b4);
		bool b5 = b1 && b2;
		System.out(b5);
		bool b6 = !b1;
		System.out(b6);

	}
```

### Результат на AVR ассемблере

```asm
; vm5277.avr_codegen v0.1 at Tue Sep 16 04:53:07 VLAT 2025
.equ stdout_port = 18

.set OS_FT_STDOUT = 1
.set OS_FT_DRAM = 1

.include "devices/atmega328p.def"
.include "core/core.asm"
.include "dmem/dram.asm"
.include "j8b/inc_refcount.asm"
.include "j8b/dec_refcount.asm"
.include "stdio/out_num8.asm"
.include "stdio/out_bool.asm"

Main:
	rjmp j8bCMainMmain
_j8b_meta20:
	.db 12,0

j8bC21CMainMtest:
	push yl
	push yh
	lds yl,SPL
	lds yh,SPH
	ldd r16,y+6
	push r16
	ldd r16,y+5
	pop j8b_atom
	and r16,j8b_atom
	ret

j8bCMainMmain:
	ldi r24,1
	ldi r20,1
	ldi r21,0
	ldi r16,1
	rcall os_out_bool
	ldi r16,0
	rcall os_out_bool
	ldi r16,0
	rcall os_out_bool
	ldi r16,1
	rcall os_out_bool
	mov r16,r20
	rcall os_out_bool
	mov r16,r21
	rcall os_out_bool
	mov r16,r20
	com r16
	rcall os_out_bool
	mov r16,r21
	com r16
	rcall os_out_bool
	mov r16,r20
	com r16
	mov r22,r16
	mov r16,r22
	rcall os_out_bool
	mov r16,r21
	cp r16,r20
	brne _j8b_eoc24
	ldi r16,48
	rcall os_out_num8
_j8b_eoc24:
	mov r16,r20
	tst r16
	breq  _j8b_eoc26
	ldi r16,49
	rcall os_out_num8
_j8b_eoc26:
	mov r16,r21
	tst r16
	breq  _j8b_eoc28
	ldi r16,50
	rcall os_out_num8
_j8b_eoc28:
	mov r16,r21
	com r16
	tst r16
	breq  _j8b_eoc30
	ldi r16,51
	rcall os_out_num8
_j8b_eoc30:
	cpi r20,0
	brne _j8b_eolb39
	cpi r21,0
	breq _j8b_eoc32
_j8b_eolb39:
	ldi r16,52
	rcall os_out_num8
_j8b_eoc32:
	cpi r20,0
	breq _j8b_eoc34
	cpi r21,0
	breq _j8b_eoc34
	ldi r16,53
	rcall os_out_num8
_j8b_eoc34:
	push zl
	push r20
	push r21
	rcall j8bC21CMainMtest
	pop j8b_atom
	pop j8b_atom
	pop zl
	rcall os_out_bool
	mov r16,r20
	push r16
	mov r16,r21
	pop j8b_atom
	or r16,j8b_atom
	push r16
	mov r16,r24
	pop j8b_atom
	or r16,j8b_atom
	mov r23,r16
	mov r16,r23
	rcall os_out_bool
	mov r16,r20
	push r16
	mov r16,r21
	pop j8b_atom
	and r16,j8b_atom
	mov r25,r16
	mov r16,r25
	rcall os_out_bool
	mov r16,r20
	com r16
	mov r26,r16
	mov r16,r26
	rcall os_out_bool
	ret
```

### Ключевые изменения
- **Generator.java**: Добавлены/обновлены методы cellsCond(), constCond(), boolCond() для обработки условий
- **BinaryExpression.java**: Добавлены проверки типов, запрещены арифметические и битовые операции с boolean, реализована кодогенерация для логических операций в присваиваниях
- **IfNode.java**: Добавлена обработка boolean выражений в условиях
- **RTOS**: Добавлена функция os_out_bool

### Достижения
1. **Полная поддержка boolean типа** во всех контекстах языка
2. **Короткое замыкание** для логических операций && и ||
3. **Интеграция с условными операторами** - автоматическое определение контекста
4. **Проверки типов** - запрет недопустимых операций с boolean


### Технические детали
- **Размер типа**: 1 байт (0x00 = false, 0x01 = true)
- **Инструкции AVR**: Использование tst, brne, breq для условий
- **Логические операции**: and, or, com для вычислений
- **Управление стеком**: Корректная передача параметров и возвращаемых значений


## [2025-09-15] - Реализация операций с фиксированной точкой (fixed Q7.8)

### ✅ Статус
Реализация завершена на уровне кодогенерации, но **не была протестирована на реальном устройстве или в симуляторе**.
Код будет всесторонне проверен и отлажен в будущем. Пока ключевая цель - общая реализация кодогенератора.
Добавлена полная поддержка типа `fixed` (Q7.8) с арифметическими операциями и выводом.

### Цель
Реализованы арифметические операции (сложение, вычитание, умножение, деление) для типа данных `fixed` (фиксированная точка Q7.8) в рамках кодогенерации для AVR.

### Исходный код (Java-подобный)

```java
import rtos.System;
import rtos.RTOSParam;

class Main {
    public static void main() {
		System.setParam(RTOSParam.STDOUT_PORT, 0x12);

		short s1 = 10;
		fixed f1 = 6;
		fixed f2 = 1.5;

		System.out(s1 + 2);
		System.out(s1 + 1.5);
		System.out(f1 + 1.5);
		System.out(s1 - 2);
		System.out(s1 - 1.5);
		System.out(f1 - 1.5);
		System.out(s1 * 2);
		System.out(s1 * 1.5);
		System.out(f1 * 1.5);
		System.out(s1 / 2);
		System.out(s1 / 1.5);
		System.out(f1 / 1.5);
		System.out(s1 % 2);

		System.out(f1 + f2);
		System.out(f1 - f2);
		System.out(f1 * f2);
		System.out(f1 / f2);
	}
}
```

### Результат на AVR ассемблере

```asm
; vm5277.avr_codegen v0.1 at Mon Sep 15 09:35:15 VLAT 2025
.equ stdout_port = 18

.set OS_FT_STDOUT = 1
.set OS_FT_DRAM = 1

.include "devices/atmega328p.def"
.include "core/core.asm"
.include "dmem/dram.asm"
.include "j8b/inc_refcount.asm"
.include "j8b/dec_refcount.asm"
.include "math/mul16.asm"
.include "math/mulq7n8.asm"
.include "math/div16.asm"
.include "math/divq7n8.asm"
.include "stdio/out_num16.asm"
.include "stdio/out_q7n8.asm"

Main:
	rjmp j8bCMainMmain
_j8b_meta19:
	.db 12,0

j8bCMainMmain:
	ldi r20,10
	ldi r21,0
	ldi r22,0
	ldi r23,6
	ldi r24,128
	ldi r25,1
	mov r16,r20
	mov r17,r21
	subi r16,254
	sbci r17,255
	rcall os_out_num16
	mov r16,r20
	mov r17,r21
	mov r17,r16
	clr r16
	subi r16,128
	sbci r17,254
	rcall os_out_q7n8
	mov r16,r22
	mov r17,r23
	subi r16,128
	sbci r17,254
	rcall os_out_q7n8
	mov r16,r20
	mov r17,r21
	subi r16,2
	sbci r17,0
	rcall os_out_num16
	mov r16,r20
	mov r17,r21
	mov r17,r16
	clr r16
	subi r16,128
	sbci r17,1
	rcall os_out_q7n8
	mov r16,r22
	mov r17,r23
	subi r16,128
	sbci r17,1
	rcall os_out_q7n8
	mov r16,r20
	mov r17,r21
	ldi ACCUM_EL,2
	ldi ACCUM_EH,0
	rcall os_mul16
	rcall os_out_num16
	mov r16,r20
	mov r17,r21
	mov r17,r16
	clr r16
	ldi ACCUM_EL,128
	ldi ACCUM_EH,1
	rcall os_mulq7n8
	rcall os_out_q7n8
	mov r16,r22
	mov r17,r23
	ldi ACCUM_EL,128
	ldi ACCUM_EH,1
	rcall os_mulq7n8
	rcall os_out_q7n8
	mov r16,r20
	mov r17,r21
	push TEMP_L
	push TEMP_H
	ldi ACCUM_EL,2
	ldi ACCUM_EH,0
	rcall os_div16
	pop TEMP_H
	pop TEMP_L
	rcall os_out_num16
	mov r16,r20
	mov r17,r21
	mov r17,r16
	clr r16
	push TEMP_L
	push TEMP_H
	ldi ACCUM_EL,128
	ldi ACCUM_EH,1
	rcall os_divq7n8
	pop TEMP_H
	pop TEMP_L
	rcall os_out_q7n8
	mov r16,r22
	mov r17,r23
	push TEMP_L
	push TEMP_H
	ldi ACCUM_EL,128
	ldi ACCUM_EH,1
	rcall os_divq7n8
	pop TEMP_H
	pop TEMP_L
	rcall os_out_q7n8
	mov r16,r20
	mov r17,r21
	push TEMP_L
	push TEMP_H
	ldi ACCUM_EL,2
	ldi ACCUM_EH,0
	rcall os_div16
	movw ACCUM_L,TEMP_L
	pop TEMP_H
	pop TEMP_L
	rcall os_out_num16
	mov r16,r24
	mov r17,r25
	add r16,r22
	adc r17,r23
	rcall os_out_q7n8
	mov r16,r22
	mov r17,r23
	sub r16,r24
	sbc r17,r25
	rcall os_out_q7n8
	mov r16,r24
	mov r17,r25
	mov ACCUM_EL,r22
	mov ACCUM_EH,r23
	rcall os_mulq7n8
	rcall os_out_q7n8
	mov r16,r22
	mov r17,r23
	mov ACCUM_EL,r24
	mov ACCUM_EH,r25
	tst r17
	brne _j8b_nediv25
	tst r18
	brne _j8b_nediv25
;TODO Division by zero
	ldi r16,0xff
	ldi r17,0xff
	rjmp _j8b_ediv24
_j8b_nediv25:
	push TEMP_L
	push TEMP_H
	rcall os_divq7n8
	pop TEMP_H
	pop TEMP_L
_j8b_ediv24:
	rcall os_out_q7n8
	ret
```

### Ключевые изменения
- **Generator.java**: Добавлена кодогенерация для операций с fixed (mulq7n8, divq7n8)
- **RTOS**: Добавлены функции os_mulq7n8, os_divq7n8, os_out_q7n8
- **ExpressionNode.java**: Оптимизация выражений с fixed
- **LiteralExpression.java**: Поддержка литералов fixed
- **VarType.java**: Добавлены константы для диапазона fixed
- **BinaryExpression.java**: Проверка типов и кодогенерация для операций с fixed

### Достижения
1. **Полная поддержка типа fixed**: Инициализация, арифметические операции, вывод.
2. **Смешанные выражения**: Операции между integer и fixed типами.
3. **Оптимизация**: Свёртывание константных выражений на этапе компиляции.
4. **Контроль ошибок**: Проверка диапазона значений при инициализации.

### Технические детали
- **Формат Q7.8**: 1 знаковый бит, 7 бит целой части, 8 бит дробной.
- **Библиотеки RTOS**: Добавлены оптимизированные ассемблерные процедуры для умножения и деления.
- **Преобразование типов**: Автоматическое приведение integer к fixed при mixed expressions.


## [2025-09-14] - Реализация математических операций в рамках кодогенерации для AVR

### ⚠️ Статус
Реализация завершена на уровне кодогенерации, но **не была протестирована на реальном устройстве или в симуляторе**.
Код будет всесторонне проверен и отлажен в будущем. Пока ключевая цель - общая реализация кодогенератора.

### Цель
Реализованы основные математические операции (сложение, вычитание, умножение, деление, остаток от деления) для целочисленных типов данных в рамках кодогенерации для AVR.
Оптимизированы цепочки арифметических выражений, добавлена поддержка операций с константами на этапе компиляции.

### Исходный код (Java-подобный)

```java
import rtos.System;
import rtos.RTOSParam;

class Main {
    public static void main() {
		System.setParam(RTOSParam.STDOUT_PORT, 0x12);

		short s1 = 10;
		short s2 = 2;
		System.out(s1 + 2);
		System.out(s1 - 2);
		System.out(s1 * 2);
		System.out(s1 / 2);
		System.out(s1 % 2);

		System.out(s1 + s2);
		System.out(s1 - s2);
		System.out(s1 * s2);
		System.out(s1 / s2);
		System.out(s1 % s2);

	}
}
```

### Результат на AVR ассемблере

```asm
; vm5277.avr_codegen v0.1 at Sun Sep 14 04:16:21 VLAT 2025
.equ stdout_port = 18

.set OS_FT_STDOUT = 1
.set OS_FT_DRAM = 1

.include "devices/atmega328p.def"
.include "core/core.asm"
.include "dmem/dram.asm"
.include "j8b/inc_refcount.asm"
.include "j8b/dec_refcount.asm"
.include "math/mul16.asm"
.include "math/div16.asm"
.include "stdio/out_num16.asm"

Main:
	rjmp j8bCMainMmain
_j8b_meta18:
	.db 12,0

j8bCMainMmain:
	ldi r20,10
	ldi r21,0
	ldi r22,2
	ldi r23,0
	mov r16,r20
	mov r17,r21
	subi r16,254
	sbci r17,255
	rcall os_out_num16

	mov r16,r20
	mov r17,r21
	subi r16,2
	sbci r17,0
	rcall os_out_num16

	mov r16,r20
	mov r17,r21
	ldi ACCUM_EL,2
	ldi ACCUM_EH,0
	rcall os_mul16
	rcall os_out_num16

	mov r16,r20
	mov r17,r21
	push TEMP_L
	push TEMP_H
	ldi ACCUM_EL,2
	ldi ACCUM_EH,0
	rcall os_div16
	pop TEMP_H
	pop TEMP_L
	rcall os_out_num16

	mov r16,r20
	mov r17,r21
	push TEMP_L
	push TEMP_H
	ldi ACCUM_EL,2
	ldi ACCUM_EH,0
	rcall os_div16
	movw ACCUM_L,TEMP_L
	pop TEMP_H
	pop TEMP_L
	rcall os_out_num16

	mov r16,r22
	mov r17,r23
	add r16,r20
	adc r17,r21
	rcall os_out_num16

	mov r16,r20
	mov r17,r21
	sub r16,r22
	sbc r17,r23
	rcall os_out_num16

	mov r16,r22
	mov r17,r23
	mov ACCUM_EL,r20
	mov ACCUM_EH,r21
	rcall os_mul16
	rcall os_out_num16

	mov r16,r20
	mov r17,r21
	mov ACCUM_EL,r22
	mov ACCUM_EH,r23
	tst r17
	brne _j8b_nediv24
	tst r18
	brne _j8b_nediv24
;TODO Division by zero
	ldi r16,0xff
	ldi r17,0xff
	rjmp _j8b_ediv23
_j8b_nediv24:
	push TEMP_L
	push TEMP_H
	rcall os_div16
	pop TEMP_H
	pop TEMP_L
_j8b_ediv23:
	rcall os_out_num16

	mov r16,r20
	mov r17,r21
	mov ACCUM_EL,r22
	mov ACCUM_EH,r23
	tst r17
	brne _j8b_nediv26
	tst r18
	brne _j8b_nediv26
;TODO Division by zero
	ldi r16,0xff
	ldi r17,0xff
	rjmp _j8b_ediv25
_j8b_nediv26:
	push TEMP_L
	push TEMP_H
	rcall os_div16
	movw ACCUM_L,TEMP_L
	pop TEMP_H
	pop TEMP_L
_j8b_ediv25:
	rcall os_out_num16
	ret
```

### Ключевые изменения
- **ExpressionNode.java**: Полностью переработаны методы оптимизации арифметических цепочек
- **Generator.java**: Реализована кодогенерация для математических операций на ассемблере AVR
- **RTOS**: Добавлены функции di8, mul16, mul32

### Достижения
1. **Поддержка математических операций**: Корректная генерация кода для +, -, *, /, %.
2. **Оптимизация выражений**: Агрессивное свертывание констант и упрощение выражений на этапе компиляции.
3. **Обработка ошибок**: Контроль деления на ноль на уровне кодогенерации.

### Технические детали
- **Процедуры умножения/деления**: Реализованы как отдельные подпрограммы (rcall os_mul8, rcall os_div16 и т.д.) в RTOS для экономии места в коде.
- **Работа с разрядностью**: Поддержка операций для 8-, 16- и 32-битных операндов.
- **Константные выражения**: Вычисления с участием констант выполняются на этапе компиляции, что уменьшает размер генерируемого кода и время выполнения.

### Следующие шаги
- Реализация операций с фиксированной точкой (fixed Q7.8)


## [2025-09-11] - Реализация работы с полями, аргументами и переменными в рамках кодогенерации для AVR

### Цель
Реализованы основные алгоритмы для инициализации, записи/передачи и чтения значений из полей класса, локальных переменных метода и аргументов.
Приведена в порядок логика создания объектов, вызова конструкторов и методов, передача параметров и возврат значения.

### Исходный код (Java-подобный)

```java
import rtos.System;
import rtos.RTOSParam;

class Main {
	class Test {
		private byte h1 = 10;
		private byte h2;

		public Test() {
			h2 = 20;
		}

		public Test(byte a) {
			h2 = a;
		}

		byte sum() {
			return h1+h2;
		}
	}

	public void go(byte b1, byte b2, byte b3) {
		byte b4 = 4;
		byte b5 = 5;

		System.out(b1);
		System.out(b2);
		System.out(b3);
		System.out(b4);
		System.out(b5);

		{
			byte b6 = 6;
			System.out(b1);
			System.out(b4);
			System.out(b5);
			System.out(b6);
		}
	}

    public static void main() {
		System.setParam(RTOSParam.STDOUT_PORT, 0x12);

		go(1,2,3);

		Test test = new Test(12);
		System.out(test.sum());
	}
}
```

### Результат на AVR ассемблере

```asm
; vm5277.avr_codegen v0.1 at Thu Sep 11 04:00:14 VLAT 2025
.equ stdout_port = 18

.set OS_FT_DRAM = 1
.set OS_FT_STDOUT = 1

.include "devices/atmega328p.def"
.include "core/core.asm"
.include "dmem/dram.asm"
.include "j8b/inc_refcount.asm"
.include "j8b/dec_refcount.asm"
.include "j8b/clear_fields.asm"
.include "stdio/out_num8.asm"

Main:
	rjmp j8bCMainMmain
_j8b_meta18:
	.db 12,0
_j8b_meta20:
	.db 13,0
_j8b_finit19:
	ldi r16,10
	std z+6,r16
	ret

j8bC24CTestMTest:
	ldi r16,low(7)
	ldi r17,high(7)
	rcall os_dram_alloc
	std z+0,r16
	std z+1,r17
	std z+2,c0x00
	ldi r16,low(_j8b_meta20*2)
	std z+3,r16
	ldi r16,high(_j8b_meta20*2)
	std z+4,r16
	rcall j8bproc_clear_fields_nr
_j8b_cinit25:
	rcall _j8b_finit19
	push yl
	push yh
	lds yl,SPL
	lds yh,SPH
	ldd r16,y+5
	std z+5,r16
	ret

j8bC27CTestMsum:
	ldd r16,z+5
	push yl
	ldd yl,z+6
	add r16,yl
	pop yl
	ret

j8bC29CMainMgo:
	push yl
	push yh
	lds yl,SPL
	lds yh,SPH
	push r20
	push r21
	ldi r20,4
	ldi r21,5
	ldd r16,y+7
	rcall os_out_num8
	ldd r16,y+6
	rcall os_out_num8
	ldd r16,y+5
	rcall os_out_num8
	mov r16,r20
	rcall os_out_num8
	mov r16,r21
	rcall os_out_num8
	push r22
	ldi r22,6
	ldd r16,y+7
	rcall os_out_num8
	mov r16,r20
	rcall os_out_num8
	mov r16,r21
	rcall os_out_num8
	mov r16,r22
	rcall os_out_num8
	pop r22
	pop r21
	pop r20
	ret

j8bCMainMmain:
	push zl
	ldi r30,1
	push r30
	ldi r30,2
	push r30
	ldi r30,3
	push r30
	rcall j8bC29CMainMgo
	pop j8b_atom
	pop j8b_atom
	pop j8b_atom
	pop zl
	push zl
	push zh
	ldi r30,12
	push r30
	rcall j8bC24CTestMTest
	pop j8b_atom
	pop zh
	pop zl
	mov r20,r16
	mov r21,r17
	push zl
	push zh
	mov r30,r20
	mov r31,r21
	rcall j8bC27CTestMsum
	pop zh
	pop zl
	rcall os_out_num8
	ret
```

### Достижения

1. **Инициализация полей**: Корректная обработка инициализации при объявлении (`private byte h1 = 10`)
2. **Поддержка конструкторов**: Добавлена поддержка нескольких конструкторов с параметрами
3. **Корректная работа со смещениями в STACK и HEAP**: Добавлены проверки смещений в инструкциях типа `ldd r16, y+const` с последующей корректировкой адреса в индексных регистрах
4. **Работа со стеком**: Корректная передача параметров и очистка стека

### Технические детали

- **Структура объекта**: 5-байтовый заголовок + поля данных
- **Смещения полей**: h1 по z+6, h2 по z+5
- **Передача параметров**: Через стек с правильной очисткой
- **Структура стека**: аргументы, адрес возврата, сохранённый Y, локальные переменные
### Следующие шаги

- Реализация математических операций
---

