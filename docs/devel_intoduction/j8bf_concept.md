## Прошивка vm5277, концепция и обоснование:

>Кратко: это дешевле, быстрее и функциональнее, чем классические программаторы, хотя и требует некоторых компромиссов.  

Приведен личный опыт автора многолетнего опыта работы с  
* **прошивками AVR:**  ATmega8/16/88/168/368, ATtiny13A,2313,25,45,85, AT90CAN32  
* **программаторами:** USBasp, USB AVRISP XPII, USB AVR JTAGIVE XPII  
* **утилитами:** Atmel Studio, Microchip Studio for AVR, arvdude и прочими  

Пожалуй главный вопрос - это возможность интеративной отладки, т.е. поддержка debugWIRE.  
К сожалению только дорогие программаторы поддрживают данный функционал, к примеру из перечисленных поддерживает ее только USB AVR JTAGIVE XPII, при этом стоимость такого программатора около 15 тысяч рублей.  
Также есть ограничения на стороне МК, большинство МК из серии ATtiny отладку не поддерживают, так-же как некоторые МК из серии ATmega.  
Более того, я не встретил ни одного функционального инструмента, который поддерживал бы отладку кроме как Atmel Studio (теперь Microchip Studio for AVR)  
И даже это не все: Atmel Studio работает только под Windows при этом 1 раз из 5 у меня возникают перманетные сбои в процессе прошивки в режиме debugWIRE.  

Также нужно учитывать общую картину прошивки Atmel микроконтроллеров. Почти всегда нужен минимум 6 пиновый порт из которых 3 порта GPIO, RESET и питание.  
В итоге самым простым способом выступает решение как у ARDUINO - установка на DEVBOARD USB-UART и запись бутлоадера в МК.  

Я хотел бы нечто подобное, но зачем ставить на каждую плату лишний чип?  
И все же хотелось бы получить механизм отладки.  
А еще моя RTOS может логировать и принимать ввод по UART и ей часто для этого нужен отдельный пин.  
А еще у нас есть пин RESET, который часто выполняет роль перезагрузки МК и больше ничего не делает, но при этом также поддерживает GPIO (правда не на всех МК).  

Проанализировав эти данные и пришел к выводу что можно сделать следующее:  
*  выделить 1 пин на МК через который можно коммуницировать в HALF-DUPLEX режиме (передача данных в обе стороны не одновременно)
* реализовать программный UART с минимальными паузами между бит и запретом перываний при обработке байта (BAUDRATE жестко привязан к частоте МК) - это позволит жестко выдерживать тайминги, выполнять передачу и прием максимально быстро. Таким образом мы не занимаем аппаратный UART и выполняем передачу и прием максимально быстро. Главное условие - внешний тактовый генератор, хотя вероятно в худшем случае (на максимальных 9.6МГц) от внутреннего тактового генератора тайминги не сильно отклонятся в пределах одного байта (каждый байт синхронизируется заново по START'у), но я бы не стал на это полагаться.
* там, где RESET может работать как GPIO - переводить его в режим GPIO, сброс будет выполняться программно через WATCHDOG. Использовать именно этот пин как минимально занятый, тем более обычно имеющий на PCB внешнюю подтяжку.
* написать бутлоадер, который будет учитывать предыдущие пункты и иметь максимально компактный протокол с возможностью расширения функционала для отладки.
* сделать утилиту формирования прошивки нашего бутлоадера и утиту прошивки ПО через наш бутлоадер попутно расширив функцуионал снабдив проект полезными фичами.
* ну и подключение - можно взять самый не дорогой и популярный USB-UART и содеинить два его порта RX+TX вместе (в большинстве случаев это допустимо, особенно если это учитывает ПО)

Таким образом, после реализации этого функционала мы получим возможность подключения к МК через один пин для быстрой прошивки, где через этот же пин можно получать логи, работать в режиме консоли (ввод/вывод) и выполнять отладку высокоуровневого кода.

Конечно не все будет идеально. Некоторые МК не поддерживают GPIO на RESET пине.  
Некоторые имеют очень маленкий объем Flash и бутлоадер в 1024 байта слишком большой для них (хотя для таких у меня есть урезанный бутлоадер в 512 байт). Но ведь отладка нужна при разработке проекта - можно взять МК и с большим Flash, а в релизе бутлоадер не ставить.  
А некоторые не имеют защищенной области для бутлоадера - а значит не будет возможности шифровать прошивку.  
И конечно новые платформы принесут свои сюрпризы, но в целом решение реальное и останется более стабильным, быстрым и функциональным.

>Поэтому VM5277 предлагает гибридный подход:  
На этапе разработки и отладки — используйте j8bf с бутлоадером для скорости и удобства  
На этапе серийного производства — перейдите на стандартные утилиты, чтобы выиграть каждый байт Flash  
Так вы получаете лучшее из двух миров: комфорт при разработке и эффективность в релизе.

[← Назад к прошивка утилитой j8bf](flashing_j8bf.md)  
[← Назад к прошивке микроконтроллера](flashing.md)  
[← Назад к содержанию](index.md)
